\documentclass[numbers=noendperiod]{scrartcl}
\usepackage[utf8]{luainputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage[a4paper,margin=0.75in, bottom=1in]{geometry}
\usepackage{enumerate}
\usepackage{minted}
\usepackage{mdframed}
\usepackage{courier}
\usepackage{hyperref}

\begin{document}
	
	\definecolor{bg}{RGB}{230,230,230}
	\newcommand{\inputmintedframed}[2]{
		\begin{mdframed}[linecolor=bg,backgroundcolor=bg]
			\inputminted[mathescape,breaklines,linenos,numbersep=5pt,tabsize=3]{#1}{#2}
	\end{mdframed}}
	
	\hrulefill
	\begin{center}
		\bfseries % Fettdruck einschalten
		\sffamily % Serifenlose Schrift
		\begin{huge}
			Betriebs- und Kommunikationssysteme
		\end{huge}\\
		\begin{Large}
			Sommersemester 2017, 3. Übungsblatt
		\end{Large}\\
		\begin{small}
			Christoph Husemann, Luis Herrmann; Tutor: André Schröder; Mi 16:00-18:00
		\end{small}
		
		\vspace{-10pt}
	\end{center}
	\hrulefill
	
\section{Aufgabe 1}
\begin{enumerate}[1.]
	\item \begin{enumerate}[a)]
		\item \textbf{Thrashing} bezeichnet ein Problem, das bei Speicherverwaltungen typischerweise auftritt, wenn viele Prozesse gleichzeitig in den Speicher geladen werden müssen, sodass Page Segments von Prozessen häufig geswappt, d.h. aus dem Speicher entfernt werden. Dabei kann der Swap unmittelbar bevor der Prozess gebraucht wird erfolgen, sodass der Page Segment sofort wieder angelegt werden muss und unnötige Lese-/Schreibzugriffe erfolgen.
		
		\item Um virtuellen Speicher zu verwalten bietet sich die Verwendung eines \textbf{Transaction Lookaside Buffer} (TLB) an, welcher als Cache für kürzlich ermittelte physische Speicheradressen dient, da diese unter Annahme von Lokalität mit hoher Wahrscheinlichkeit unmittelbar nach dem erstem Aufruf erneut aufgerufen werden und dank Caching die virtuelle Adresse nicht jedes Mal unter Rechenaufwand neu auf eine physische Adresse abgebildet werden muss, sondern direkt in dem TLB abgerufen werden kann.
		
		\item Die \textbf{Memory Management Unit} (MMU) ist eine Hardwareeinheit des Prozessors, welche die Funktion eines Hardware-Supports für Speicherverwaltung, inbesondere für Paging und Speichervirtualisierung erfüllt und u.a. die Abbildung von virtuellen Adressen in physische Speicheradressen vornimmt.
		
		\item Eine \textbf{physikalische Adresse} bezeichnet eine Speicheradresse, welche als Bezeichner für eine auf einem physisch vorhandenen Speicher (z.B. RAM) vorhandenen Speicherstelle dient.
		
		\item \textbf{Logische/virtuelle Adressen} führen eine zusätzliche Abstraktionsebene ein, welche für den Nutzer die Speicheradressierung vereinfacht, da im virtuellen Adressraum des Speichers keine interne Fragmentierung existiert und Prozesse zusammenhängende Adressräume haben, wobei die virtuellen Adressen natürlich auf tatsächliche, physische Adressen verweisen, die Zuweisung aber für den Benutzer unsichtbar durch die Speicherverwaltung des Betriebssystems durchgeführt wird.
		
		\item Ein \textbf{Adressraum} bezeichnet eine Menge an Speicheradressen in einem Speicher, welche referenziert werden können.
	\end{enumerate}
	
	\item \textbf{Externe und interne Fragmentierung / Paging}
		\begin{enumerate}
			\item \textbf{Interne Fragmentierung} tritt bei fester Speicheraufteilung (fixed partition) auf. Dabei wird Speicher verschwendet, weil die Speicherbereiche fest definierter Größe fast nie komplett genutzt werden können. Der Rest der Speicherzellen in dem festen Speicherbereich bleibt ungenutzt. Im Beispiel aus der Vorlesung wurde Speicher im Hauptspeicher für Prozesse mit unterschiedlichem Speicherbedarf angefordert. In fast allen Fällen bleibt ungenutzter Speicher im zugeordneten Speicherbereich übrig, der mindestens solange nicht verwendet werden kann, wie der Speicherbereich für den Prozess nicht wieder freigegeben wird.
			 
			\item \textbf{Externe Fragmentierung} bei dynamischer Speicheraufteilung (dynamic partionions) verschwendet Speicher, weil die leeren Speicherbereiche an verschiedenen Stellen im Speicher stehen und keinen zusammenhängenden Speicherbereich ergeben, der sinnvollerweise neu genutzt werden könnte. Die Nutzung von nicht-zusammenhängenden Speicherbereichen ist für das Betriebssystem aufwendig. Im Beispiel aus der Vorlesung blieben nach dem Austauschen verschiedener Speicherbereiche für Prozesse fast immer an verschiedenen Stellen kleine, ungenutzte Speicherbereiche übrig. Diese können zwar theoretisch neu belegt werden, allerdings sind sie für die Speicherbereiche der meisten Prozesse zu klein.
			\item Bei \textbf{Paging} wird der Speicher in viele, kleine Seitenrahmen (page-frames) gleicher Speichergröße aufgeteilt. Der Speicher eines Prozesses wird in Seiten (Pages) gleicher Speichergröße aufgeteilt. Eine Seite des Prozesses wird einem Seitenrahmen des Speichers zugeordnet. Das Betriebssystem hält für jeden Prozess eine Tabelle (page table) vor, die Seitenrahmen des Speichers den Seiten des Prozesses zuordnet. Die Verwaltung der Tabelle findet in der MMU statt. So kann externe Fragmentierung verhindert werden, weil alle Seitenrahmen des Speichers für Seiten der Prozesse verwendet werden können. Interne Fragmentierung bleibt möglich, allerdings nur in einem Seitenrahmen pro Prozess. Da die Seitenrahmen sehr klein sind, ist der Speicherverlust ebenfalls sehr klein.
				
		\end{enumerate}
	
	\item
	
\end{enumerate}
\section{Aufgabe 2}
\subsection*{4}
Folgende Sonderfälle sind insbesondere bei der Neubelegung freigegebener Speicherknoten zu berücksichtigen:
\begin{enumerate}
	\item Zusammenhängende, dereferenzierte Speicherknoten müssen zusammengefügt werden.
	\item Bei der Anforderung eines Speicherbereichs innerhalb eines größeren, dereferenzierten Speicherknoten muss der restliche Speicher als neuer, dereferenzierter Speicherknoten abgespalten werden.
	\item Wenn der neue, dereferenzierte Speicherbereich zwischen zwei Knoten zu klein für einen neuen Speicherknoten ist, muss der Speicherbereich des vorherigen Knotens um die Differenz größer ausfallen, als angefordert.
\end{enumerate}
Alle diese Sonderfälle wurden in unserem Programm berücksichtigt. Die memory\_allocate()-Funktion geht dabei nach einem First-Fit Algorithmus vor.
	
\end{document}
